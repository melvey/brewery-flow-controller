
#include <stdio.h>
#include <string.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include "usart.h"
#include "lcdpcf8574.h"

#define ENABLE_LCD 1

#define HOLD_COUNT 100
#define TAP_THRESHOLD 10
#define TICKS_PER_LITRE 356
#define OVERFLOW_TICKS 65535
#define SERIAL_BUFFER_SIZE 15
#define SERIAL_DEVICE_INDEX 2
#define SERIAL_DEVICE_LENGTH 2
#define SERIAL_CMD_INDEX 3
#define TIMER0_OVERFLOW_COUNT 125
#define INCREASE_VOLUME 1000
#define DEBOUNCE_DELAY 3 // Debounce delay in timer 0 overflows (16ms intervals)
const int BUTTON_PIN = PD6;
const int SOLENOID_PIN = PINB1;
const char DEVICE_ID[2] = "F1";
const char SERIAL_DATA_CMD = 'D';
const char SERIAL_MSG_CMD = 'M';
const char SERIAL_SET_TARGET_CMD = 'T';
const int SERIAL_SET_TARGET_CMD_LENGTH = 9;
const char SERIAL_START = 0x02;
const char SERIAL_END = 0x03;

unsigned int oldTicks = 0;
unsigned int newTicks = 0;
unsigned long flowRate = 0;
int updateDisplay = 0;
int updateTicks = 0;
int flowStatus = 0;
unsigned int overflows = 0;
unsigned long volume = 0;
unsigned int flowOverflow = 0;
unsigned int pressStart = 0;
unsigned int targetVolume = 1500;
char serialBuffer[SERIAL_BUFFER_SIZE];
unsigned short int bufferIndex = 0;
unsigned long lastDebounceTime = 0;
uint8_t lastButtonState = 0;
uint8_t buttonState = 0;


void sendMessage(const char *message) {
    uint8_t messageLength = strlen(message);
    uint8_t totalChunks = (messageLength + 19) / 20; // Calculate the number of chunks required to send the message

    for (uint8_t chunk = 0; chunk < totalChunks; chunk++) {
        USART_Write(SERIAL_START);
        USART_Write(DEVICE_ID[0]);
        USART_Write(DEVICE_ID[1]);
        USART_Write(SERIAL_MSG_CMD);

        for (uint8_t i = 0; i < 20; i++) {
            uint8_t index = chunk * 20 + i;
            if (index < messageLength) {
                USART_Write(message[index]);
            } else {
                USART_Write(' '); // Fill with spaces if there is no more data
            }
        }

        USART_Write(SERIAL_END);
    }
}

union LongByte
{
    unsigned long value;
    char chars[4];
};

// Timer0 Overflow ISR
ISR(TIMER0_OVF_vect){
	//Timer 0 overflows every 16ms. Capturing 125 of these gives us a 2 s interval.
    overflows++;
    if(overflows >= TIMER0_OVERFLOW_COUNT){
		//Get timer 1 count and record it
        overflows = 0;
        newTicks = TCNT1;
        updateTicks = 1;
    }
}

/** 
 * Calculate the current flow rate in ml
 **/
unsigned long calculateFlowRate(int ticks) {
	// This runs at 2 second intervals so ticks * 30 is ticks per minute
	// Multiply by 1000 to get ml
    return (ticks * 30000L) / TICKS_PER_LITRE;
}

/**
 * Calculate the current volume from tick count in ml
 **/
unsigned long calculateVolume(int ticks, int volOverflows) {
    return (((volOverflows * (unsigned long)OVERFLOW_TICKS) + ticks) * 1000) / TICKS_PER_LITRE;
}

void onTap(void) {
	// If we are chasing a target volume increase that
	// Otherwise set a target volume above the current
    if(targetVolume > volume) {
        targetVolume += INCREASE_VOLUME;
    } else {
        targetVolume = volume + INCREASE_VOLUME;
    }
}

void onHold(void) {
    targetVolume = 0;
}

void onRelease(void) {
    targetVolume = volume;
}


void handleButton(void) {
    // Read the current button state
    uint8_t currentButtonState = (PIND & (1 << BUTTON_PIN)) != 0;

    // If the button state has changed, reset the debounce timer
    if (currentButtonState != lastButtonState) {
        lastDebounceTime = overflows;
    }

    // If enough time has passed since the last button state change, update the button state
    // We need to account for overflows here so just check if it overflowed more than the debounce time ago
    if(
        (overflows < lastDebounceTime && overflows > DEBOUNCE_DELAY)
        || (overflows - lastDebounceTime) > DEBOUNCE_DELAY
    ) {
        if (currentButtonState != buttonState) {
            buttonState = currentButtonState;

            if (buttonState) {
                // Button is pressed
                pressStart++;
                if (pressStart > HOLD_COUNT) {
                    onHold();
                }
            } else {
                // Button is released
                if (pressStart > HOLD_COUNT) {
                    onRelease();
                } else if (pressStart > TAP_THRESHOLD) {
                    onTap();
                }
                pressStart = 0;
            }
        }
    }

    lastButtonState = currentButtonState;
}

void openFlow(void) {
    flowStatus = 1;
	PORTB = PORTB | (1<<SOLENOID_PIN); // Write high value to SOLENOID PIN (digitalWrite)
}

void closeFlow(void) {
    flowStatus = 0;
	PORTB = PORTB & (0<<SOLENOID_PIN); // Write low value to SOLENOID PIN (digitalWrite)
}

void readInput(void) {
    char readChar;
    while (USART_Ready() == 1) {
        readChar = USART_Receive();
        USART_Write(readChar);
        if (bufferIndex > 0) {
            serialBuffer[bufferIndex] = readChar;
            bufferIndex++;

            // Check for ETX character
            if (readChar == SERIAL_END) {
 //               sendMessage("Got end command");
                // If the device ID matches and the command and length are correct, update the target volume
                if (strncmp(serialBuffer + SERIAL_DEVICE_INDEX, DEVICE_ID, SERIAL_DEVICE_LENGTH) == 0) {
   //                 sendMessage("Device ID matches");
                    if(serialBuffer[SERIAL_CMD_INDEX] == SERIAL_SET_TARGET_CMD) {
                        sendMessage("Update volume");
                        //targetVolume = ((uint8_t)serialBuffer[SERIAL_CMD_INDEX + 1] << 8) | (uint8_t)serialBuffer[SERIAL_CMD_INDEX + 2];
                        memcpy(&targetVolume, &serialBuffer[SERIAL_CMD_INDEX + 1], sizeof(targetVolume));
                    }
                }
                
                // Reset the buffer index
                bufferIndex = 0;
            }

            // Reset the buffer index if it exceeds the buffer size
            if (bufferIndex >= SERIAL_BUFFER_SIZE) {
                bufferIndex = 0;
            }
        } else if (readChar == SERIAL_START) {
       //     sendMessage("Got start command");
            serialBuffer[0] = readChar;
            bufferIndex = 1;
        }
    }
}
void serialUpdate(void) {
    union LongByte flowBytes;
    flowBytes.value = flowRate;
    union LongByte volumeBytes;
    volumeBytes.value = volume;
    union LongByte tickBytes;
    tickBytes.value = newTicks;
    union LongByte targetBytes;
    targetBytes.value = targetVolume;
    union LongByte status;
    status.value = flowStatus;

    int msgLength = 25;
    char message[msgLength];
    message[0] = SERIAL_START;
    memcpy(&message[1], &DEVICE_ID, 2);
    message[3] = SERIAL_DATA_CMD;

    memcpy(&message[4], &flowBytes.chars, 4);
    memcpy(&message[8], &volumeBytes.chars, 4);
    memcpy(&message[12], &tickBytes.chars, 4);
    memcpy(&message[16], &targetBytes.chars, 4);
    memcpy(&message[20], &status.chars, 4);
    message[24] = SERIAL_END;
    for(int i = 0; i < msgLength; i++) {
        USART_Write(message[i]);
    }
}

void displayVolume(void) {
    lcd_gotoxy(1, 0);
    char tmp[21];
    lcd_puts("Vol:");
    lcd_gotoxy(5, 0);
    ultoa(volume, tmp, 10);
    lcd_puts(tmp);
    lcd_gotoxy(1, 1);
    lcd_puts("Ticks:");
    lcd_gotoxy(7, 1);
    utoa(oldTicks, tmp, 10);
    lcd_puts(tmp);
}

void setupLCD(void) {
    char tmp = LCD_DISP_ON_BLINK;
    lcd_init(LCD_DISP_ON_BLINK);
    lcd_home();
    lcd_led(0);
    int line = 0;
    lcd_gotoxy(1, line);
    lcd_puts("Starting");
}

void configureTimer0(void) {
    //Set Timer 0 to normal mode, 1/1024 prescaler
	TCCR0A = 0x00; //Set register to default value (probably not required)
	TCCR0B = 0x00; //Set register to default value (probably not required)
	TCCR0B |= (1 << CS02) | (1 << CS00); //prescaler set to 1/1024. Counter will overflow ever 16 ms

	TIMSK0 |= (1 << TOIE0); // Enable Timer 0 overflow interupt
}

void configureTimer1(void) {
	// Setup flow controller counter 
	// init counter to count up and increment on external pin T1 rising edge
	TCCR1A = 0x00;
	TCCR1B = 0x07; // 0x00 | (1<<CS12) | (1<<CS11) | (1<<CS10)
	// Zero counter
	TCNT1 = 0x0000;
}

void configureTimer2(void) {
    // Set Timer 2 to phase correct PWM, clear ouput on count up match, no prescaler (31kHz)
	TCCR2A = 0x00; //Set register to default value (probably not required)
	TCCR2B = 0x00; //Set register to default value (probably not required)
	TCCR2A |= (1 << WGM20); //Timer 2 set for phase corrected PWM
	TCCR2A |= (1 << COM2A1)|(1 << COM2B1); //OC2A and OC2B clear on match counting up set when counting down
	TCCR2B |= (1 << CS20); //No prescale on timer source
}

void setupPinModes(void) {
	DDRB |= 0b00001010;//set PORTB so that D9 & D11 are outputs
	DDRD = 0b00001010; //set PORTD so that D1 & D3 are outputs, D0, D2, D4-D7 are inputs
}

void initializeSerial(void) {
    USART_Init();
    USART_Flush();
}

int main(void) {
    setupPinModes();
    configureTimer0();
    configureTimer1();
    configureTimer2();

    initializeSerial();

    sei();

    openFlow();

    #if ENABLE_LCD == 1
        setupLCD();
    #endif

    sendMessage("Starting");
    serialUpdate();
    while(1) {
        readInput();
        handleButton();

        if(updateTicks) {
            updateTicks = 0;

            if(newTicks != oldTicks) {
                if(newTicks > oldTicks) {
                    flowRate = calculateFlowRate(newTicks - oldTicks);
                } else {
                    flowRate = calculateFlowRate((newTicks + OVERFLOW_TICKS) - oldTicks);
                }
                volume = calculateVolume(newTicks, flowOverflow);
                oldTicks = newTicks;

                if(targetVolume > 0 && volume >= targetVolume) {
                    closeFlow();
                } else if(targetVolume == 0 || volume < targetVolume) {
                    openFlow();
                }

                updateDisplay = 1;
            } else {
                flowRate = 0;
            }

            #if ENABLE_LCD == 1
                displayVolume();
            #endif

            serialUpdate();
        }

        _delay_ms(100);
    }
    return 1;
}
